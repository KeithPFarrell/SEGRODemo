# Exception Count Synchronization Fix

## Issue Identified
The Dashboard and Reporting Cycles pages were showing incorrect exception counts that didn't match the actual number of exceptions displayed on the Exceptions screen.

### Root Cause:
1. **Hardcoded Counts**: The mock cycle data had hardcoded exception counts (e.g., total: 5, hard: 2, soft: 3)
2. **Dynamic Generation**: The actual exceptions were generated dynamically with a random count (3-8 exceptions)
3. **No Synchronization**: There was no mechanism to keep the cycle's exception counts in sync with the actual exceptions

### Specific Discrepancy:
- **Dashboard/Cycles showed**: 5 total (2 hard, 3 soft)
- **Exceptions screen showed**: 8 total (4 hard, 4 soft)

## Solution Implemented

### 1. **Exception Count Synchronization Function**
Created a central `syncExceptionCounts()` function that:
- Iterates through all cycles
- Counts actual exceptions by severity and status
- Updates each cycle's exceptionCounts to match reality

```typescript
function syncExceptionCounts() {
  cycles.forEach(cycle => {
    const cycleExceptions = exceptions[cycle.id] || [];
    const hardCount = cycleExceptions.filter(
      e => e.severity === 'Hard' && e.status !== 'resolved'
    ).length;
    const softCount = cycleExceptions.filter(
      e => e.severity === 'Soft' && e.status !== 'resolved'
    ).length;
    const resolvedCount = cycleExceptions.filter(
      e => e.status === 'resolved'
    ).length;

    cycle.exceptionCounts = {
      total: hardCount + softCount,
      hard: hardCount,
      soft: softCount,
      resolved: resolvedCount,
    };
  });
}
```

### 2. **Initial Synchronization**
- Generate exceptions FIRST
- Generate cycles SECOND
- Call `syncExceptionCounts()` immediately after initialization

```typescript
// In-memory storage - Initialize exceptions first
let exceptions: Record<string, ExceptionItem[]> = {
  'cycle-2024-01': generateMockExceptions('cycle-2024-01', 42),
  'cycle-2023-12': [],
};

// Generate cycles and sync exception counts
let cycles = generateMockCycles();

// Initial sync
syncExceptionCounts();
```

### 3. **Dynamic Synchronization on Updates**
Call `syncExceptionCounts()` after any exception modification:

**a) When resolving exceptions:**
```typescript
export async function resolveException(...) {
  // ... resolve exception logic ...
  
  // Sync exception counts
  syncExceptionCounts();
  
  return exception;
}
```

**b) When updating exceptions:**
```typescript
export async function updateException(...) {
  // ... update exception logic ...
  
  // Sync exception counts
  syncExceptionCounts();
  
  return exception;
}
```

**c) During orchestration (Validate step):**
```typescript
if (step === 'Validate') {
  const newExceptions = generateMockExceptions(cycle.id, Date.now());
  exceptions[cycle.id] = newExceptions;

  // Sync exception counts with actual generated exceptions
  syncExceptionCounts();
  
  logActivity(...);
}
```

## Changes Made

**File: `/home/node/txai-projects/project/src/mock/api.ts`**

### Modified Sections:

1. **Initialization Order** (Lines 23-50):
   - Moved exception generation before cycle generation
   - Added `syncExceptionCounts()` function
   - Called initial sync after setup

2. **updateException()** (Line 234):
   - Added `syncExceptionCounts()` call after updates

3. **resolveException()** (Line 266):
   - Removed manual count increment
   - Added `syncExceptionCounts()` call

4. **simulateOrchestration() - Validate step** (Line 147):
   - Removed manual count calculations
   - Added `syncExceptionCounts()` call

## Benefits

### 1. **Accurate Counts Everywhere**
- Dashboard shows correct exception counts
- Reporting Cycles page shows correct counts
- Exception counts match actual exceptions in Exceptions screen

### 2. **Real-Time Updates**
- Counts update automatically when exceptions are resolved
- Counts update when new exceptions are generated
- No stale data

### 3. **Single Source of Truth**
- All counts calculated from actual exception data
- No hardcoded values to maintain
- No possibility of count drift

### 4. **Consistent Logic**
- One function handles all count calculations
- Easy to modify counting logic in one place
- Excludes resolved exceptions from active counts

## Testing

### To Verify the Fix:

1. **Check Dashboard:**
   ```
   - Navigate to Dashboard
   - Note the "Active Exceptions" count
   - Note the Hard/Soft breakdown
   ```

2. **Check Reporting Cycles:**
   ```
   - Navigate to Reporting Cycles
   - Select "January 2024 Reporting" cycle
   - Check Exception Summary at bottom
   - Note the counts
   ```

3. **Check Exceptions Screen:**
   ```
   - Navigate to Exceptions
   - Filter by "Open" status
   - Count the exceptions manually
   - Verify counts match Dashboard/Cycles
   ```

4. **Test Dynamic Updates:**
   ```
   - Resolve an exception
   - Return to Dashboard
   - Verify counts decreased
   - Verify resolved count increased
   ```

5. **Test Orchestration:**
   ```
   - Navigate to Reporting Cycles
   - Select "February 2024 Reporting"
   - Click "Run Report Now"
   - Wait for Validate step to complete
   - Check exception counts match actual exceptions
   ```

## Expected Results

### Before Fix:
- Dashboard: 5 exceptions (2 hard, 3 soft)
- Exceptions screen: 8 exceptions (4 hard, 4 soft)
- **Mismatch!**

### After Fix:
- Dashboard: 8 exceptions (4 hard, 4 soft)
- Reporting Cycles: 8 exceptions (4 hard, 4 soft)
- Exceptions screen: 8 exceptions (4 hard, 4 soft)
- **All match!**

### After Resolving 1 Exception:
- Dashboard: 7 exceptions (X hard, Y soft, 1 resolved)
- Reporting Cycles: 7 exceptions (X hard, Y soft, 1 resolved)
- Exceptions screen: 7 open + 1 resolved
- **All match!**

## Technical Details

### Count Logic:
- **Total**: Hard + Soft (excluding resolved)
- **Hard**: Exceptions with `severity === 'Hard'` and `status !== 'resolved'`
- **Soft**: Exceptions with `severity === 'Soft'` and `status !== 'resolved'`
- **Resolved**: Exceptions with `status === 'resolved'` (any severity)

### Performance:
- Sync function is O(n*m) where n = cycles, m = avg exceptions per cycle
- For typical data (3 cycles, 5-10 exceptions each), this is negligible
- Called only when data changes, not on every read

### Data Consistency:
- Exception counts are always derived, never stored independently
- Eliminates possibility of count drift
- Guarantees accuracy across all views
